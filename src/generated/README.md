# Generated Entity APIs and Hooks

This directory contains auto-generated API instances and React hooks for all entities in the project.

⚠️ **DO NOT MODIFY THESE FILES MANUALLY** - They are generated by the `npm run generate-entity-apis` script.

## Files

- `apis.ts` - Contains API instances for all entities using the EntityAPI pattern
- `hooks.ts` - Contains React hooks with Preact signals for state management
- `index.ts` - Main export file for easy importing

## Generation

To regenerate these files after entity changes:

```bash
npm run generate-entity-apis
```

## Usage Examples

### Using Hooks in Components

```tsx
import { useUser, useLead, useCountry } from '../generated';

export function UserList() {
  // Basic usage - fetches all users
  const users = useUser();

  // With conditions and includes
  const activeUsers = useUser(
    { IsActive: true }, // conditions
    { Country: {}, Role: {} }, // includes
    100 // limit
  );

  // Effect to load data on component mount
  useEffect(() => {
    users.fetch();
    activeUsers.fetch();
  }, []);

  if (users.loading) return <div>Loading...</div>;
  if (users.error) return <div>Error: {users.error}</div>;

  return (
    <div>
      <h2>Users ({users.data?.length})</h2>
      {users.data?.map((user) => (
        <div key={user.Id}>
          {user.FirstName} {user.LastName} - {user.Email}
          {user.Country && <span> ({user.Country.Name})</span>}
        </div>
      ))}
    </div>
  );
}
```

### Creating New Records

```tsx
import { useUser } from '../generated';

export function CreateUser() {
  const users = useUser();

  const handleCreate = async () => {
    try {
      const newUser = await users.create({
        Username: 'johndoe',
        FirstName: 'John',
        LastName: 'Doe',
        Email: 'john@example.com',
        IsActive: true,
        PhoneNumber: null,
        CountryId: 1 as Id<Country>,
        RoleId: 1 as Id<Role>,
        TypeId: 1 as Id<ClientType>,
        Name: 'John Doe',
        MfaEnable: false,
        MfaType: null,
      });
      console.log('Created user:', newUser);
    } catch (error) {
      console.error('Failed to create user:', error);
    }
  };

  return (
    <button onClick={handleCreate} disabled={users.loading}>
      {users.loading ? 'Creating...' : 'Create User'}
    </button>
  );
}
```

### Updating Records

```tsx
import { useUser } from '../generated';

export function UpdateUser({ userId }: { userId: Id<User> }) {
  const users = useUser();

  const handleUpdate = async () => {
    try {
      const updatedUser = await users.update(userId, {
        FirstName: 'Jane',
        LastName: 'Smith',
        Email: 'jane.smith@example.com',
      });
      console.log('Updated user:', updatedUser);
    } catch (error) {
      console.error('Failed to update user:', error);
    }
  };

  return (
    <button onClick={handleUpdate} disabled={users.loading}>
      {users.loading ? 'Updating...' : 'Update User'}
    </button>
  );
}
```

### Using APIs Directly

If you need more control, you can use the API instances directly:

```tsx
import { UserAPI, LeadAPI } from '../generated';

// Direct API usage
const users = await UserAPI.apiq({
  Where: { IsActive: true },
  Include: { Country: {}, Role: {} },
  Limit: 50,
});

const newUser = await UserAPI.insert({
  Username: 'jane',
  FirstName: 'Jane',
  LastName: 'Doe',
  Email: 'jane@example.com',
  // ... other required fields
});

const updatedUser = await UserAPI.update(userId, {
  FirstName: 'Jane Updated',
});
```

### Available Hook Features

Each hook returns an object with:

- `data: T[] | null` - The fetched data
- `loading: boolean` - Loading state
- `error: string | null` - Error message if any
- `fetch()` - Function to fetch data
- `create(entity)` - Function to create new record
- `update(id, entity)` - Function to update record
- `refresh()` - Alias for fetch()

### Hook State Management

All hooks use Preact signals for reactive state management. The state automatically updates components when data changes.

### Entity Relationships

When using `Include` parameters, related entities are automatically loaded:

```tsx
const { data } = useUser(
  {}, // no conditions
  {
    Country: {}, // Include country data
    Role: {}, // Include role data
    Type: {}, // Include client type data
  }
);

// Now you can access related data
data?.forEach((user) => {
  console.log(user.Country?.Name); // Country name
  console.log(user.Role?.Name); // Role name
});
```

## Type Safety

All APIs and hooks are fully typed with TypeScript, providing:

- Auto-completion for entity properties
- Type checking for conditions and includes
- Proper return types for all methods
- Type-safe ID handling with `Id<T>` types

## Error Handling

All hooks include error handling:

```tsx
const users = useUser();

useEffect(() => {
  users.fetch().catch((error) => {
    // Handle specific errors
    console.error('Failed to fetch users:', error);
  });
}, []);

// Or check the error state
if (users.error) {
  return <ErrorComponent message={users.error} />;
}
```

## Best Practices

1. **Use hooks for components** - They provide reactive state management
2. **Use APIs directly for services** - For complex business logic
3. **Handle loading states** - Always check `loading` before rendering data
4. **Handle errors gracefully** - Check `error` state and provide fallbacks
5. **Fetch data in effects** - Use `useEffect` to load data on mount
6. **Use proper TypeScript types** - Leverage the generated types for safety
