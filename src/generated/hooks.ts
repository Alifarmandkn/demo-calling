// Auto-generated file - do not modify manually
// Generated by: npm run generate-entity-apis
// 
// This file contains React/Preact hooks for all entities.
// Each entity has its own hook with the following properties:
// - data: Entity[] | null - The current data
// - loading: boolean - Loading state
// - error: Error | null - Error state
// 
// Usage Example:
// import { useUser } from './generated/hooks';
// 
// // In your component:
// function UserList() {
//   const { data: users, loading, error, fetch } = useUser();
//   
//   useEffect(() => {
//     fetch({ IsActive: true });
//   }, [fetch]);
// 
//   if (loading) return <div>Loading...</div>;
//   if (error) return <div>Error: {error.message}</div>;
//   return <div>{users?.map(user => <div key={user.Id}>{user.Name}</div>)}</div>;
// }

import { useState, useCallback } from 'react';

import type { ActionDetail } from '../entities/ActionDetail.ts';
import { ActionDetailAPI, ActionDetailTypeInfo } from './apis.ts';
import type { ActionDetail_Conditions, ActionDetail_Includes } from '../entities/ActionDetail.apiq.d.ts';
import type { ActionType } from '../entities/ActionType.ts';
import { ActionTypeAPI } from './apis.ts';
import type { ActionType_Conditions, ActionType_Includes } from '../entities/ActionType.apiq.d.ts';
import type { CallFlow } from '../entities/CallFlow.ts';
import { CallFlowAPI, CallFlowTypeInfo } from './apis.ts';
import type { CallFlow_Conditions, CallFlow_Includes } from '../entities/CallFlow.apiq.d.ts';
import type { CallTracing } from '../entities/CallTracing.ts';
import { CallTracingAPI } from './apis.ts';
import type { CallTracing_Conditions, CallTracing_Includes } from '../entities/CallTracing.apiq.d.ts';
import type { Campaign } from '../entities/Campaign.ts';
import { CampaignAPI, CampaignTypeInfo } from './apis.ts';
import type { Campaign_Conditions, Campaign_Includes } from '../entities/Campaign.apiq.d.ts';
import type { CampaignSetting } from '../entities/CampaignSetting.ts';
import { CampaignSettingAPI, CampaignSettingTypeInfo } from './apis.ts';
import type { CampaignSetting_Conditions, CampaignSetting_Includes } from '../entities/CampaignSetting.apiq.d.ts';
import type { CampaignSettingVirtualAgentRel } from '../entities/CampaignSettingVirtualAgentRel.ts';
import { CampaignSettingVirtualAgentRelAPI, CampaignSettingVirtualAgentRelTypeInfo } from './apis.ts';
import type { CampaignSettingVirtualAgentRel_Conditions, CampaignSettingVirtualAgentRel_Includes } from '../entities/CampaignSettingVirtualAgentRel.apiq.d.ts';
import type { CampaignType } from '../entities/CampaignType.ts';
import { CampaignTypeAPI } from './apis.ts';
import type { CampaignType_Conditions, CampaignType_Includes } from '../entities/CampaignType.apiq.d.ts';
import type { Client } from '../entities/Client.ts';
import { ClientAPI } from './apis.ts';
import type { Client_Conditions, Client_Includes } from '../entities/Client.apiq.d.ts';
import type { ClientDialingConfig } from '../entities/ClientDialingConfig.ts';
import { ClientDialingConfigAPI } from './apis.ts';
import type { ClientDialingConfig_Conditions, ClientDialingConfig_Includes } from '../entities/ClientDialingConfig.apiq.d.ts';
import type { CommProviderAccount } from '../entities/CommProviderAccount.ts';
import { CommProviderAccountAPI } from './apis.ts';
import type { CommProviderAccount_Conditions, CommProviderAccount_Includes } from '../entities/CommProviderAccount.apiq.d.ts';
import type { CommProviderType } from '../entities/CommProviderType.ts';
import { CommProviderTypeAPI } from './apis.ts';
import type { CommProviderType_Conditions, CommProviderType_Includes } from '../entities/CommProviderType.apiq.d.ts';
import type { Contact } from '../entities/Contact.ts';
import { ContactAPI, ContactTypeInfo } from './apis.ts';
import type { Contact_Conditions, Contact_Includes } from '../entities/Contact.apiq.d.ts';
import type { ContactCall } from '../entities/ContactCall.ts';
import { ContactCallAPI } from './apis.ts';
import type { ContactCall_Conditions, ContactCall_Includes } from '../entities/ContactCall.apiq.d.ts';
import type { ContactList } from '../entities/ContactList.ts';
import { ContactListAPI, ContactListTypeInfo } from './apis.ts';
import type { ContactList_Conditions, ContactList_Includes } from '../entities/ContactList.apiq.d.ts';
import type { ContactPhaseLog } from '../entities/ContactPhaseLog.ts';
import { ContactPhaseLogAPI } from './apis.ts';
import type { ContactPhaseLog_Conditions, ContactPhaseLog_Includes } from '../entities/ContactPhaseLog.apiq.d.ts';
import type { ContactPhaseLogReferenceData } from '../entities/ContactPhaseLogReferenceData.ts';
import { ContactPhaseLogReferenceDataAPI } from './apis.ts';
import type { ContactPhaseLogReferenceData_Conditions, ContactPhaseLogReferenceData_Includes } from '../entities/ContactPhaseLogReferenceData.apiq.d.ts';
import type { ContactSms } from '../entities/ContactSms.ts';
import { ContactSmsAPI, ContactSmsTypeInfo } from './apis.ts';
import type { ContactSms_Conditions, ContactSms_Includes } from '../entities/ContactSms.apiq.d.ts';
import type { Country } from '../entities/Country.ts';
import { CountryAPI } from './apis.ts';
import type { Country_Conditions, Country_Includes } from '../entities/Country.apiq.d.ts';
import type { Document } from '../entities/Document.ts';
import { DocumentAPI } from './apis.ts';
import type { DocumentType } from '../entities/DocumentType.ts';
import { DocumentTypeAPI } from './apis.ts';
import type { DocumentType_Conditions, DocumentType_Includes } from '../entities/DocumentType.apiq.d.ts';
import type { Environment } from '../entities/Environment.ts';
import { EnvironmentAPI } from './apis.ts';
import type { GlobalDialingConfig } from '../entities/GlobalDialingConfig.ts';
import { GlobalDialingConfigAPI } from './apis.ts';
import type { InboundNumber } from '../entities/InboundNumber.ts';
import { InboundNumberAPI, InboundNumberTypeInfo } from './apis.ts';
import type { InboundNumber_Conditions, InboundNumber_Includes } from '../entities/InboundNumber.apiq.d.ts';
import type { KeyValueStore } from '../entities/KeyValueStore.ts';
import { KeyValueStoreAPI } from './apis.ts';
import type { KeyValueStore_Conditions, KeyValueStore_Includes } from '../entities/KeyValueStore.apiq.d.ts';
import type { MessageStatus } from '../entities/MessageStatus.ts';
import { MessageStatusAPI } from './apis.ts';
import type { MessageStatus_Conditions, MessageStatus_Includes } from '../entities/MessageStatus.apiq.d.ts';
import type { OpeningHour } from '../entities/OpeningHour.ts';
import { OpeningHourAPI, OpeningHourTypeInfo } from './apis.ts';
import type { OpeningHour_Conditions, OpeningHour_Includes } from '../entities/OpeningHour.apiq.d.ts';
import type { Phase } from '../entities/Phase.ts';
import { PhaseAPI } from './apis.ts';
import type { Phase_Conditions, Phase_Includes } from '../entities/Phase.apiq.d.ts';
import type { Project } from '../entities/Project.ts';
import { ProjectAPI, ProjectTypeInfo } from './apis.ts';
import type { Project_Conditions, Project_Includes } from '../entities/Project.apiq.d.ts';
import type { Role } from '../entities/Role.ts';
import { RoleAPI } from './apis.ts';
import type { Role_Conditions, Role_Includes } from '../entities/Role.apiq.d.ts';
import type { User } from '../entities/User.ts';
import { UserAPI, UserTypeInfo } from './apis.ts';
import type { User_Conditions, User_Includes } from '../entities/User.apiq.d.ts';
import type { VirtualAgentDetail } from '../entities/VirtualAgentDetail.ts';
import { VirtualAgentDetailAPI, VirtualAgentDetailTypeInfo } from './apis.ts';
import type { VirtualAgentDetail_Conditions, VirtualAgentDetail_Includes } from '../entities/VirtualAgentDetail.apiq.d.ts';
import type { VoicebotServer } from '../entities/VoicebotServer.ts';
import { VoicebotServerAPI, VoicebotServerTypeInfo } from './apis.ts';
import type { VoicebotServer_Conditions, VoicebotServer_Includes } from '../entities/VoicebotServer.apiq.d.ts';


// Hook for ActionDetail
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 11, Insertable properties: 18
export function useActionDetail() {
  const [data, setData] = useState<ActionDetail[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ActionDetail_Conditions, includes?: ActionDetail_Includes, limit?: number): Promise<ActionDetail[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionDetailAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ActionDetail[]);
      return result as ActionDetail[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionDetailHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ActionDetail[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionDetailAPI.apiq({});
      setData(result as ActionDetail[]);
      return result as ActionDetail[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionDetailHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 18 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ActionDetailAPI.insert>[0]): Promise<ActionDetail> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionDetailAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ActionDetailHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionDetailHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 11 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof ActionDetailAPI.update>[1]): Promise<ActionDetail> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionDetailAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(ActionDetailTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[ActionDetailHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionDetailHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await ActionDetailAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[ActionDetailHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionDetailHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ActionDetailHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ActionDetail. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'ActionDetail',
    isInternal: false
  };
}

// Hook for ActionType
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 1
export function useActionType() {
  const [data, setData] = useState<ActionType[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ActionType_Conditions, includes?: ActionType_Includes, limit?: number): Promise<ActionType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionTypeAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ActionType[]);
      return result as ActionType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionTypeHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ActionType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionTypeAPI.apiq({});
      setData(result as ActionType[]);
      return result as ActionType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionTypeHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 1 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ActionTypeAPI.insert>[0]): Promise<ActionType> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ActionTypeAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ActionTypeHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ActionTypeHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for ActionType (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ActionTypeHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ActionType. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'ActionType',
    isInternal: false
  };
}

// Hook for CallFlow
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 4, Insertable properties: 5
export function useCallFlow() {
  const [data, setData] = useState<CallFlow[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CallFlow_Conditions, includes?: CallFlow_Includes, limit?: number): Promise<CallFlow[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallFlowAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CallFlow[]);
      return result as CallFlow[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallFlowHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CallFlow[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallFlowAPI.apiq({});
      setData(result as CallFlow[]);
      return result as CallFlow[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallFlowHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 5 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CallFlowAPI.insert>[0]): Promise<CallFlow> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallFlowAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CallFlowHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallFlowHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 4 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof CallFlowAPI.update>[1]): Promise<CallFlow> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallFlowAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(CallFlowTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[CallFlowHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallFlowHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CallFlowHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CallFlow. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'CallFlow',
    isInternal: false
  };
}

// Hook for CallTracing
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 6
export function useCallTracing() {
  const [data, setData] = useState<CallTracing[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CallTracing_Conditions, includes?: CallTracing_Includes, limit?: number): Promise<CallTracing[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallTracingAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CallTracing[]);
      return result as CallTracing[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallTracingHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CallTracing[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallTracingAPI.apiq({});
      setData(result as CallTracing[]);
      return result as CallTracing[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallTracingHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 6 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CallTracingAPI.insert>[0]): Promise<CallTracing> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CallTracingAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CallTracingHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CallTracingHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for CallTracing (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CallTracingHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CallTracing. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'CallTracing',
    isInternal: false
  };
}

// Hook for Campaign
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 5, Insertable properties: 9
export function useCampaign() {
  const [data, setData] = useState<Campaign[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Campaign_Conditions, includes?: Campaign_Includes, limit?: number): Promise<Campaign[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Campaign[]);
      return result as Campaign[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Campaign[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignAPI.apiq({});
      setData(result as Campaign[]);
      return result as Campaign[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 9 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CampaignAPI.insert>[0]): Promise<Campaign> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CampaignHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 5 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof CampaignAPI.update>[1]): Promise<Campaign> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(CampaignTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[CampaignHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await CampaignAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[CampaignHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CampaignHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Campaign. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'Campaign',
    isInternal: false
  };
}

// Hook for CampaignSetting
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 18, Insertable properties: 20
export function useCampaignSetting() {
  const [data, setData] = useState<CampaignSetting[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CampaignSetting_Conditions, includes?: CampaignSetting_Includes, limit?: number): Promise<CampaignSetting[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CampaignSetting[]);
      return result as CampaignSetting[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CampaignSetting[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingAPI.apiq({});
      setData(result as CampaignSetting[]);
      return result as CampaignSetting[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 20 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CampaignSettingAPI.insert>[0]): Promise<CampaignSetting> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CampaignSettingHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 18 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof CampaignSettingAPI.update>[1]): Promise<CampaignSetting> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(CampaignSettingTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[CampaignSettingHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CampaignSettingHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CampaignSetting. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'CampaignSetting',
    isInternal: false
  };
}

// Hook for CampaignSettingVirtualAgentRel
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 2, Insertable properties: 3
export function useCampaignSettingVirtualAgentRel() {
  const [data, setData] = useState<CampaignSettingVirtualAgentRel[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CampaignSettingVirtualAgentRel_Conditions, includes?: CampaignSettingVirtualAgentRel_Includes, limit?: number): Promise<CampaignSettingVirtualAgentRel[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingVirtualAgentRelAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CampaignSettingVirtualAgentRel[]);
      return result as CampaignSettingVirtualAgentRel[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingVirtualAgentRelHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CampaignSettingVirtualAgentRel[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingVirtualAgentRelAPI.apiq({});
      setData(result as CampaignSettingVirtualAgentRel[]);
      return result as CampaignSettingVirtualAgentRel[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingVirtualAgentRelHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 3 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CampaignSettingVirtualAgentRelAPI.insert>[0]): Promise<CampaignSettingVirtualAgentRel> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingVirtualAgentRelAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CampaignSettingVirtualAgentRelHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingVirtualAgentRelHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 2 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof CampaignSettingVirtualAgentRelAPI.update>[1]): Promise<CampaignSettingVirtualAgentRel> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignSettingVirtualAgentRelAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(CampaignSettingVirtualAgentRelTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[CampaignSettingVirtualAgentRelHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignSettingVirtualAgentRelHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CampaignSettingVirtualAgentRelHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CampaignSettingVirtualAgentRel. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'CampaignSettingVirtualAgentRel',
    isInternal: false
  };
}

// Hook for CampaignType
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 3
export function useCampaignType() {
  const [data, setData] = useState<CampaignType[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CampaignType_Conditions, includes?: CampaignType_Includes, limit?: number): Promise<CampaignType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignTypeAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CampaignType[]);
      return result as CampaignType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignTypeHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CampaignType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignTypeAPI.apiq({});
      setData(result as CampaignType[]);
      return result as CampaignType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignTypeHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 3 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CampaignTypeAPI.insert>[0]): Promise<CampaignType> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CampaignTypeAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CampaignTypeHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CampaignTypeHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for CampaignType (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CampaignTypeHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CampaignType. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'CampaignType',
    isInternal: false
  };
}

// Hook for Client
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=true
// Updatable properties: 0, Insertable properties: 7
export function useClient() {
  const [data, setData] = useState<Client[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Client_Conditions, includes?: Client_Includes, limit?: number): Promise<Client[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ClientAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Client[]);
      return result as Client[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Client[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ClientAPI.apiq({});
      setData(result as Client[]);
      return result as Client[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 7 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ClientAPI.insert>[0]): Promise<Client> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ClientAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ClientHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Client (No updatable properties detected)

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await ClientAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[ClientHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ClientHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Client. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true},
    entityName: 'Client',
    isInternal: true
  };
}

// Hook for ClientDialingConfig
// Capabilities: fetch=true, getAll=true, create=false, update=false, delete=false
// Updatable properties: 0, Insertable properties: 0
export function useClientDialingConfig() {
  const [data, setData] = useState<ClientDialingConfig[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ClientDialingConfig_Conditions, includes?: ClientDialingConfig_Includes, limit?: number): Promise<ClientDialingConfig[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ClientDialingConfigAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ClientDialingConfig[]);
      return result as ClientDialingConfig[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientDialingConfigHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ClientDialingConfig[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ClientDialingConfigAPI.apiq({});
      setData(result as ClientDialingConfig[]);
      return result as ClientDialingConfig[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ClientDialingConfigHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create operation not supported for ClientDialingConfig (No insertable properties detected)

  
  // Update operation not supported for ClientDialingConfig (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ClientDialingConfigHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":false,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ClientDialingConfig. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":false,"update":false,"delete":false},
    entityName: 'ClientDialingConfig',
    isInternal: false
  };
}

// Hook for CommProviderAccount
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=true
// Updatable properties: 0, Insertable properties: 3
export function useCommProviderAccount() {
  const [data, setData] = useState<CommProviderAccount[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CommProviderAccount_Conditions, includes?: CommProviderAccount_Includes, limit?: number): Promise<CommProviderAccount[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderAccountAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CommProviderAccount[]);
      return result as CommProviderAccount[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderAccountHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CommProviderAccount[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderAccountAPI.apiq({});
      setData(result as CommProviderAccount[]);
      return result as CommProviderAccount[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderAccountHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 3 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CommProviderAccountAPI.insert>[0]): Promise<CommProviderAccount> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderAccountAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CommProviderAccountHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderAccountHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for CommProviderAccount (No updatable properties detected)

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await CommProviderAccountAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[CommProviderAccountHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderAccountHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CommProviderAccountHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CommProviderAccount. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true},
    entityName: 'CommProviderAccount',
    isInternal: false
  };
}

// Hook for CommProviderType
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 1
export function useCommProviderType() {
  const [data, setData] = useState<CommProviderType[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: CommProviderType_Conditions, includes?: CommProviderType_Includes, limit?: number): Promise<CommProviderType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderTypeAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as CommProviderType[]);
      return result as CommProviderType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderTypeHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<CommProviderType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderTypeAPI.apiq({});
      setData(result as CommProviderType[]);
      return result as CommProviderType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderTypeHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 1 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CommProviderTypeAPI.insert>[0]): Promise<CommProviderType> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CommProviderTypeAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CommProviderTypeHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CommProviderTypeHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for CommProviderType (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CommProviderTypeHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for CommProviderType. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'CommProviderType',
    isInternal: false
  };
}

// Hook for Contact
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 34, Insertable properties: 41
export function useContact() {
  const [data, setData] = useState<Contact[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Contact_Conditions, includes?: Contact_Includes, limit?: number): Promise<Contact[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Contact[]);
      return result as Contact[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Contact[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactAPI.apiq({});
      setData(result as Contact[]);
      return result as Contact[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 41 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactAPI.insert>[0]): Promise<Contact> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 34 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof ContactAPI.update>[1]): Promise<Contact> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(ContactTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[ContactHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Contact. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'Contact',
    isInternal: false
  };
}

// Hook for ContactCall
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 11
export function useContactCall() {
  const [data, setData] = useState<ContactCall[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ContactCall_Conditions, includes?: ContactCall_Includes, limit?: number): Promise<ContactCall[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactCallAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ContactCall[]);
      return result as ContactCall[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactCallHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ContactCall[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactCallAPI.apiq({});
      setData(result as ContactCall[]);
      return result as ContactCall[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactCallHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 11 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactCallAPI.insert>[0]): Promise<ContactCall> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactCallAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactCallHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactCallHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for ContactCall (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactCallHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ContactCall. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'ContactCall',
    isInternal: false
  };
}

// Hook for ContactList
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 7, Insertable properties: 7
export function useContactList() {
  const [data, setData] = useState<ContactList[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ContactList_Conditions, includes?: ContactList_Includes, limit?: number): Promise<ContactList[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactListAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ContactList[]);
      return result as ContactList[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactListHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ContactList[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactListAPI.apiq({});
      setData(result as ContactList[]);
      return result as ContactList[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactListHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 7 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactListAPI.insert>[0]): Promise<ContactList> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactListAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactListHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactListHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 7 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof ContactListAPI.update>[1]): Promise<ContactList> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactListAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(ContactListTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[ContactListHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactListHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await ContactListAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[ContactListHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactListHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactListHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ContactList. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'ContactList',
    isInternal: false
  };
}

// Hook for ContactPhaseLog
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 6
export function useContactPhaseLog() {
  const [data, setData] = useState<ContactPhaseLog[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ContactPhaseLog_Conditions, includes?: ContactPhaseLog_Includes, limit?: number): Promise<ContactPhaseLog[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ContactPhaseLog[]);
      return result as ContactPhaseLog[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ContactPhaseLog[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogAPI.apiq({});
      setData(result as ContactPhaseLog[]);
      return result as ContactPhaseLog[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 6 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactPhaseLogAPI.insert>[0]): Promise<ContactPhaseLog> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactPhaseLogHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for ContactPhaseLog (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactPhaseLogHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ContactPhaseLog. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'ContactPhaseLog',
    isInternal: false
  };
}

// Hook for ContactPhaseLogReferenceData
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 3
export function useContactPhaseLogReferenceData() {
  const [data, setData] = useState<ContactPhaseLogReferenceData[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ContactPhaseLogReferenceData_Conditions, includes?: ContactPhaseLogReferenceData_Includes, limit?: number): Promise<ContactPhaseLogReferenceData[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogReferenceDataAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ContactPhaseLogReferenceData[]);
      return result as ContactPhaseLogReferenceData[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogReferenceDataHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ContactPhaseLogReferenceData[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogReferenceDataAPI.apiq({});
      setData(result as ContactPhaseLogReferenceData[]);
      return result as ContactPhaseLogReferenceData[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogReferenceDataHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 3 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactPhaseLogReferenceDataAPI.insert>[0]): Promise<ContactPhaseLogReferenceData> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactPhaseLogReferenceDataAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactPhaseLogReferenceDataHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactPhaseLogReferenceDataHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for ContactPhaseLogReferenceData (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactPhaseLogReferenceDataHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ContactPhaseLogReferenceData. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'ContactPhaseLogReferenceData',
    isInternal: false
  };
}

// Hook for ContactSms
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 1, Insertable properties: 8
export function useContactSms() {
  const [data, setData] = useState<ContactSms[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: ContactSms_Conditions, includes?: ContactSms_Includes, limit?: number): Promise<ContactSms[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactSmsAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as ContactSms[]);
      return result as ContactSms[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactSmsHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<ContactSms[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactSmsAPI.apiq({});
      setData(result as ContactSms[]);
      return result as ContactSms[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactSmsHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 8 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ContactSmsAPI.insert>[0]): Promise<ContactSms> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactSmsAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ContactSmsHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactSmsHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 1 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof ContactSmsAPI.update>[1]): Promise<ContactSms> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ContactSmsAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(ContactSmsTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[ContactSmsHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ContactSmsHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ContactSmsHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for ContactSms. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'ContactSms',
    isInternal: false
  };
}

// Hook for Country
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 4
export function useCountry() {
  const [data, setData] = useState<Country[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Country_Conditions, includes?: Country_Includes, limit?: number): Promise<Country[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CountryAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Country[]);
      return result as Country[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CountryHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Country[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CountryAPI.apiq({});
      setData(result as Country[]);
      return result as Country[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CountryHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 4 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof CountryAPI.insert>[0]): Promise<Country> => {
    setLoading(true);
    setError(null);
    try {
      const result = await CountryAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[CountryHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[CountryHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Country (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[CountryHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Country. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'Country',
    isInternal: false
  };
}

// Hook for Document
// Capabilities: fetch=false, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 7
export function useDocument() {
  const [data, setData] = useState<Document[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Document[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await DocumentAPI.getAll();
      setData(result as Document[]);
      return result as Document[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 7 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof DocumentAPI.insert>[0]): Promise<Document> => {
    setLoading(true);
    setError(null);
    try {
      const result = await DocumentAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[DocumentHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Document (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[DocumentHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":false,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Document. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":false,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'Document',
    isInternal: false
  };
}

// Hook for DocumentType
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=true
// Updatable properties: 0, Insertable properties: 4
export function useDocumentType() {
  const [data, setData] = useState<DocumentType[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: DocumentType_Conditions, includes?: DocumentType_Includes, limit?: number): Promise<DocumentType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await DocumentTypeAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as DocumentType[]);
      return result as DocumentType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentTypeHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<DocumentType[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await DocumentTypeAPI.apiq({});
      setData(result as DocumentType[]);
      return result as DocumentType[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentTypeHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 4 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof DocumentTypeAPI.insert>[0]): Promise<DocumentType> => {
    setLoading(true);
    setError(null);
    try {
      const result = await DocumentTypeAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[DocumentTypeHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentTypeHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for DocumentType (No updatable properties detected)

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await DocumentTypeAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[DocumentTypeHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[DocumentTypeHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[DocumentTypeHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for DocumentType. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":true},
    entityName: 'DocumentType',
    isInternal: false
  };
}

// Hook for Environment
// Capabilities: fetch=false, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 1
export function useEnvironment() {
  const [data, setData] = useState<Environment[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Environment[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await EnvironmentAPI.getAll();
      setData(result as Environment[]);
      return result as Environment[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[EnvironmentHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 1 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof EnvironmentAPI.insert>[0]): Promise<Environment> => {
    setLoading(true);
    setError(null);
    try {
      const result = await EnvironmentAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[EnvironmentHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[EnvironmentHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Environment (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[EnvironmentHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":false,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Environment. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":false,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'Environment',
    isInternal: false
  };
}

// Hook for GlobalDialingConfig
// Capabilities: fetch=false, getAll=true, create=false, update=false, delete=false
// Updatable properties: 0, Insertable properties: 0
export function useGlobalDialingConfig() {
  const [data, setData] = useState<GlobalDialingConfig[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<GlobalDialingConfig[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await GlobalDialingConfigAPI.getAll();
      setData(result as GlobalDialingConfig[]);
      return result as GlobalDialingConfig[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[GlobalDialingConfigHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create operation not supported for GlobalDialingConfig (No insertable properties detected)

  
  // Update operation not supported for GlobalDialingConfig (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[GlobalDialingConfigHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":false,"getAll":true,"create":false,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for GlobalDialingConfig. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    getAll,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":false,"getAll":true,"create":false,"update":false,"delete":false},
    entityName: 'GlobalDialingConfig',
    isInternal: false
  };
}

// Hook for InboundNumber
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 4, Insertable properties: 8
export function useInboundNumber() {
  const [data, setData] = useState<InboundNumber[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: InboundNumber_Conditions, includes?: InboundNumber_Includes, limit?: number): Promise<InboundNumber[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await InboundNumberAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as InboundNumber[]);
      return result as InboundNumber[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[InboundNumberHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<InboundNumber[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await InboundNumberAPI.apiq({});
      setData(result as InboundNumber[]);
      return result as InboundNumber[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[InboundNumberHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 8 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof InboundNumberAPI.insert>[0]): Promise<InboundNumber> => {
    setLoading(true);
    setError(null);
    try {
      const result = await InboundNumberAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[InboundNumberHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[InboundNumberHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 4 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof InboundNumberAPI.update>[1]): Promise<InboundNumber> => {
    setLoading(true);
    setError(null);
    try {
      const result = await InboundNumberAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(InboundNumberTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[InboundNumberHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[InboundNumberHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await InboundNumberAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[InboundNumberHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[InboundNumberHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[InboundNumberHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for InboundNumber. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'InboundNumber',
    isInternal: false
  };
}

// Hook for KeyValueStore
// Capabilities: fetch=true, getAll=true, create=false, update=false, delete=false
// Updatable properties: 0, Insertable properties: 0
export function useKeyValueStore() {
  const [data, setData] = useState<KeyValueStore[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: KeyValueStore_Conditions, includes?: KeyValueStore_Includes, limit?: number): Promise<KeyValueStore[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await KeyValueStoreAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as KeyValueStore[]);
      return result as KeyValueStore[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[KeyValueStoreHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<KeyValueStore[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await KeyValueStoreAPI.apiq({});
      setData(result as KeyValueStore[]);
      return result as KeyValueStore[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[KeyValueStoreHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create operation not supported for KeyValueStore (No insertable properties detected)

  
  // Update operation not supported for KeyValueStore (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[KeyValueStoreHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":false,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for KeyValueStore. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":false,"update":false,"delete":false},
    entityName: 'KeyValueStore',
    isInternal: false
  };
}

// Hook for MessageStatus
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 1
export function useMessageStatus() {
  const [data, setData] = useState<MessageStatus[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: MessageStatus_Conditions, includes?: MessageStatus_Includes, limit?: number): Promise<MessageStatus[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await MessageStatusAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as MessageStatus[]);
      return result as MessageStatus[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[MessageStatusHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<MessageStatus[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await MessageStatusAPI.apiq({});
      setData(result as MessageStatus[]);
      return result as MessageStatus[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[MessageStatusHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 1 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof MessageStatusAPI.insert>[0]): Promise<MessageStatus> => {
    setLoading(true);
    setError(null);
    try {
      const result = await MessageStatusAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[MessageStatusHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[MessageStatusHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for MessageStatus (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[MessageStatusHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for MessageStatus. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'MessageStatus',
    isInternal: false
  };
}

// Hook for OpeningHour
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 3, Insertable properties: 6
export function useOpeningHour() {
  const [data, setData] = useState<OpeningHour[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: OpeningHour_Conditions, includes?: OpeningHour_Includes, limit?: number): Promise<OpeningHour[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await OpeningHourAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as OpeningHour[]);
      return result as OpeningHour[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[OpeningHourHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<OpeningHour[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await OpeningHourAPI.apiq({});
      setData(result as OpeningHour[]);
      return result as OpeningHour[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[OpeningHourHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 6 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof OpeningHourAPI.insert>[0]): Promise<OpeningHour> => {
    setLoading(true);
    setError(null);
    try {
      const result = await OpeningHourAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[OpeningHourHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[OpeningHourHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 3 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof OpeningHourAPI.update>[1]): Promise<OpeningHour> => {
    setLoading(true);
    setError(null);
    try {
      const result = await OpeningHourAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(OpeningHourTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[OpeningHourHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[OpeningHourHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[OpeningHourHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for OpeningHour. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'OpeningHour',
    isInternal: false
  };
}

// Hook for Phase
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 8
export function usePhase() {
  const [data, setData] = useState<Phase[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Phase_Conditions, includes?: Phase_Includes, limit?: number): Promise<Phase[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await PhaseAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Phase[]);
      return result as Phase[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[PhaseHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Phase[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await PhaseAPI.apiq({});
      setData(result as Phase[]);
      return result as Phase[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[PhaseHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 8 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof PhaseAPI.insert>[0]): Promise<Phase> => {
    setLoading(true);
    setError(null);
    try {
      const result = await PhaseAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[PhaseHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[PhaseHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Phase (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[PhaseHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Phase. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'Phase',
    isInternal: false
  };
}

// Hook for Project
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 5, Insertable properties: 6
export function useProject() {
  const [data, setData] = useState<Project[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Project_Conditions, includes?: Project_Includes, limit?: number): Promise<Project[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ProjectAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Project[]);
      return result as Project[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ProjectHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Project[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ProjectAPI.apiq({});
      setData(result as Project[]);
      return result as Project[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ProjectHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 6 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof ProjectAPI.insert>[0]): Promise<Project> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ProjectAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[ProjectHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ProjectHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 5 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof ProjectAPI.update>[1]): Promise<Project> => {
    setLoading(true);
    setError(null);
    try {
      const result = await ProjectAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(ProjectTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[ProjectHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ProjectHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await ProjectAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[ProjectHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[ProjectHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[ProjectHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Project. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'Project',
    isInternal: false
  };
}

// Hook for Role
// Capabilities: fetch=true, getAll=true, create=true, update=false, delete=false
// Updatable properties: 0, Insertable properties: 1
export function useRole() {
  const [data, setData] = useState<Role[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: Role_Conditions, includes?: Role_Includes, limit?: number): Promise<Role[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await RoleAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as Role[]);
      return result as Role[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[RoleHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<Role[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await RoleAPI.apiq({});
      setData(result as Role[]);
      return result as Role[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[RoleHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 1 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof RoleAPI.insert>[0]): Promise<Role> => {
    setLoading(true);
    setError(null);
    try {
      const result = await RoleAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[RoleHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[RoleHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update operation not supported for Role (No updatable properties detected)

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[RoleHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for Role. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":false,"delete":false},
    entityName: 'Role',
    isInternal: false
  };
}

// Hook for User
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 11, Insertable properties: 11
export function useUser() {
  const [data, setData] = useState<User[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: User_Conditions, includes?: User_Includes, limit?: number): Promise<User[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await UserAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as User[]);
      return result as User[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[UserHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<User[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await UserAPI.apiq({});
      setData(result as User[]);
      return result as User[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[UserHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 11 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof UserAPI.insert>[0]): Promise<User> => {
    setLoading(true);
    setError(null);
    try {
      const result = await UserAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[UserHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[UserHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 11 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof UserAPI.update>[1]): Promise<User> => {
    setLoading(true);
    setError(null);
    try {
      const result = await UserAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(UserTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[UserHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[UserHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await UserAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[UserHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[UserHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[UserHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for User. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'User',
    isInternal: false
  };
}

// Hook for VirtualAgentDetail
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=true
// Updatable properties: 16, Insertable properties: 17
export function useVirtualAgentDetail() {
  const [data, setData] = useState<VirtualAgentDetail[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: VirtualAgentDetail_Conditions, includes?: VirtualAgentDetail_Includes, limit?: number): Promise<VirtualAgentDetail[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VirtualAgentDetailAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as VirtualAgentDetail[]);
      return result as VirtualAgentDetail[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VirtualAgentDetailHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<VirtualAgentDetail[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VirtualAgentDetailAPI.apiq({});
      setData(result as VirtualAgentDetail[]);
      return result as VirtualAgentDetail[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VirtualAgentDetailHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 17 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof VirtualAgentDetailAPI.insert>[0]): Promise<VirtualAgentDetail> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VirtualAgentDetailAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[VirtualAgentDetailHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VirtualAgentDetailHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 16 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof VirtualAgentDetailAPI.update>[1]): Promise<VirtualAgentDetail> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VirtualAgentDetailAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(VirtualAgentDetailTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[VirtualAgentDetailHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VirtualAgentDetailHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Soft delete entity (Delete support detected)
  const softDelete = useCallback(async (id: any): Promise<void> => {
    setLoading(true);
    setError(null);
    try {
      // Assuming soft delete via IsActive = false or similar pattern
      await VirtualAgentDetailAPI.update(id, { IsActive: false } as any);
      setData(prev => prev ? prev.filter(item => (item as any).Id !== id) : null);
      console.log('[VirtualAgentDetailHook] Successfully soft deleted entity:', { id });
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VirtualAgentDetailHook] Error soft deleting entity:', {
        id,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[VirtualAgentDetailHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for VirtualAgentDetail. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    softDelete,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":true},
    entityName: 'VirtualAgentDetail',
    isInternal: false
  };
}

// Hook for VoicebotServer
// Capabilities: fetch=true, getAll=true, create=true, update=true, delete=false
// Updatable properties: 1, Insertable properties: 2
export function useVoicebotServer() {
  const [data, setData] = useState<VoicebotServer[] | null>(null);
  const [loading, setLoading] = useState<boolean>(false);
  const [error, setError] = useState<Error | null>(null);
  
  
  // Fetch data with conditions (Query support detected)
  const fetch = useCallback(async (conditions?: VoicebotServer_Conditions, includes?: VoicebotServer_Includes, limit?: number): Promise<VoicebotServer[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VoicebotServerAPI.apiq({
        Where: conditions || {},
        Include: includes || {},
        Limit: limit
      });
      setData(result as VoicebotServer[]);
      return result as VoicebotServer[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VoicebotServerHook] Error fetching with conditions:', {
        conditions,
        includes,
        limit,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  // Get all entities (Always available via apiq)
  const getAll = useCallback(async (): Promise<VoicebotServer[]> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VoicebotServerAPI.apiq({});
      setData(result as VoicebotServer[]);
      return result as VoicebotServer[];
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VoicebotServerHook] Error getting all entities:', {
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Create new entity (Insert support detected: 2 insertable properties)
  const create = useCallback(async (entityData: Parameters<typeof VoicebotServerAPI.insert>[0]): Promise<VoicebotServer> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VoicebotServerAPI.insert(entityData);
      setData(prev => prev ? [...prev, result] : [result]);
      console.log('[VoicebotServerHook] Successfully created entity:', { id: (result as any).Id });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VoicebotServerHook] Error creating entity:', {
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  
  // Update existing entity (Update support detected: 1 updatable properties)
  const update = useCallback(async (id: any, entityData: Parameters<typeof VoicebotServerAPI.update>[1]): Promise<VoicebotServer> => {
    setLoading(true);
    setError(null);
    try {
      const result = await VoicebotServerAPI.update(id, entityData);
      // Find primary key field from TypeInfo to update the correct field
      const primaryKeyField = Object.entries(VoicebotServerTypeInfo.Properties).find(([_, prop]: [string, any]) => prop.PrimaryKeyOrder === 0)?.[0];
      setData(prev => prev ? prev.map(item => ((item as any)[primaryKeyField || 'Id'] === id ? result : item)) : [result]);
      console.log('[VoicebotServerHook] Successfully updated entity:', { id, primaryKeyField });
      return result;
    } catch (err) {
      const error = err instanceof Error ? err : new Error(String(err));
      setError(error);
      console.error('[VoicebotServerHook] Error updating entity:', {
        id,
        entityData,
        error: error.message,
        stack: error.stack
      });
      throw error;
    } finally {
      setLoading(false);
    }
  }, []);

  

  // Reset state
  const reset = useCallback(() => {
    setData(null);
    setLoading(false);
    setError(null);
    console.log('[VoicebotServerHook] State reset');
  }, []);

  // Validation helper
  const validateOperation = useCallback((operation: string) => {
    const supportedOps = {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false};
    if (!supportedOps[operation as keyof typeof supportedOps]) {
      throw new Error(`Operation '${operation}' is not supported for VoicebotServer. Supported operations: ${Object.entries(supportedOps).filter(([_, v]) => v).map(([k]) => k).join(', ')}`);
    }
  }, []);

  return {
    // Data and state
    data,
    loading,
    error,
    
    // Operations (conditionally included based on entity capabilities)
    fetch,
    getAll,
    create,
    update,
    
    // Always available utilities
    reset,
    validateOperation,
    
    // Metadata
    capabilities: {"fetch":true,"getAll":true,"create":true,"update":true,"delete":false},
    entityName: 'VoicebotServer',
    isInternal: false
  };
}
